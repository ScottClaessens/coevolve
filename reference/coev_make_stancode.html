<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Make Stan code for dynamic coevolutionary model — coev_make_stancode • coevolve</title><!-- favicons --><link rel="icon" type="image/png" sizes="48x48" href="../favicon-48x48.png"><link rel="icon" type="”image/svg+xml”" href="../favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png"><link rel="icon" sizes="any" href="../favicon.ico"><link rel="manifest" href="../site.webmanifest"><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Make Stan code for dynamic coevolutionary model — coev_make_stancode"><meta property="og:description" content="Make the Stan code for the Bayesian dynamic coevolutionary model.
Stan code is generated, checked for syntactical errors, and then
returned as a character string."><meta property="og:image" content="https://scottclaessens.github.io/coevolve/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">


    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">coevolve</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.1.0.9001</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/coevolve.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/ScottClaessens/coevolve/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Make Stan code for dynamic coevolutionary model</h1>
    <small class="dont-index">Source: <a href="https://github.com/ScottClaessens/coevolve/blob/main/R/coev_make_stancode.R" class="external-link"><code>R/coev_make_stancode.R</code></a></small>
    <div class="hidden name"><code>coev_make_stancode.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Make the <span class="pkg">Stan</span> code for the Bayesian dynamic coevolutionary model.
<span class="pkg">Stan</span> code is generated, checked for syntactical errors, and then
returned as a character string.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">coev_make_stancode</span><span class="op">(</span></span>
<span>  <span class="va">data</span>,</span>
<span>  <span class="va">variables</span>,</span>
<span>  <span class="va">id</span>,</span>
<span>  <span class="va">tree</span>,</span>
<span>  effects_mat <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  complete_cases <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  dist_mat <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  dist_cov <span class="op">=</span> <span class="st">"exp_quad"</span>,</span>
<span>  measurement_error <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  prior <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  scale <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  estimate_correlated_drift <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  estimate_residual <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  log_lik <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  prior_only <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>


<dl><dt id="arg-data">data<a class="anchor" aria-label="anchor" href="#arg-data"></a></dt>
<dd><p>An object of class <code>data.frame</code> (or one that can be coerced
to that class) containing data of all variables used in the model.</p></dd>


<dt id="arg-variables">variables<a class="anchor" aria-label="anchor" href="#arg-variables"></a></dt>
<dd><p>A named list identifying variables that should coevolve in
the model and their associated response distributions as character strings
(e.g. <code>list(var1 = "bernoulli_logit", var2 = "ordered_logistic")</code>).
Must identify at least two variables. Variable names must refer to valid
column names in data. Currently, the only supported response distributions
are <code>bernoulli_logit</code>, <code>ordered_logistic</code>,
<code>poisson_softplus</code>, <code>negative_binomial_softplus</code>, <code>normal</code>,
and <code>gamma_log</code>.</p></dd>


<dt id="arg-id">id<a class="anchor" aria-label="anchor" href="#arg-id"></a></dt>
<dd><p>A character of length one identifying the variable in the data that
links rows to tips on the phylogeny. Must refer to a valid column name in
the data. The id column must exactly match the tip labels in the phylogeny.</p></dd>


<dt id="arg-tree">tree<a class="anchor" aria-label="anchor" href="#arg-tree"></a></dt>
<dd><p>A phylogenetic tree object of class <code>phylo</code> or
<code>multiPhylo</code>. The tree(s) must be rooted and must include positive
non-zero branch lengths. All trees in <code>multiPhylo</code> objects must have
the same number of internal nodes and branches.</p></dd>


<dt id="arg-effects-mat">effects_mat<a class="anchor" aria-label="anchor" href="#arg-effects-mat"></a></dt>
<dd><p>(optional) A boolean matrix with row and column names
exactly matching the variables declared for the model. If not specified,
all cross-lagged effects will be estimated in the model. If specified, the
model will only estimate cross-lagged effects where cells in the matrix are
TRUE and will ignore cross-lagged effects where cells in the matrix are
FALSE. In the matrix, columns represent predictor variables and rows
represent outcome variables. All autoregressive effects (e.g., X -&gt; X) must
be TRUE in the matrix.</p></dd>


<dt id="arg-complete-cases">complete_cases<a class="anchor" aria-label="anchor" href="#arg-complete-cases"></a></dt>
<dd><p>(optional) Logical. If <code>FALSE</code> (default), all
missing values are imputed by the model. If <code>TRUE</code>, taxa with missing
data are excluded.</p></dd>


<dt id="arg-dist-mat">dist_mat<a class="anchor" aria-label="anchor" href="#arg-dist-mat"></a></dt>
<dd><p>(optional) A distance matrix with row and column names
exactly matching the tip labels in the phylogeny. If specified, the model
will additionally control for spatial location by including a separate
Gaussian Process over locations for every coevolving variable in the model.</p></dd>


<dt id="arg-dist-cov">dist_cov<a class="anchor" aria-label="anchor" href="#arg-dist-cov"></a></dt>
<dd><p>A string specifying the covariance kernel used for Gaussian
Processes over locations. Currently supported are <code>"exp_quad"</code>
(exponentiated-quadratic kernel; default), <code>"exponential"</code>
(exponential kernel), and <code>"matern32"</code> (Matern 3/2 kernel).</p></dd>


<dt id="arg-measurement-error">measurement_error<a class="anchor" aria-label="anchor" href="#arg-measurement-error"></a></dt>
<dd><p>(optional) A named list of coevolving variables and
their associated columns in the dataset containing standard errors. Only
valid for normally-distributed variables. For example, if we declare
<code>variables = list(x = "normal", y = "normal")</code>, then we could set
<code>measurement_error = list(x = "x_std_err")</code> to tell the function to
include measurement error on <code>x</code> using standard errors from the
<code>x_std_err</code> column of the dataset.</p></dd>


<dt id="arg-prior">prior<a class="anchor" aria-label="anchor" href="#arg-prior"></a></dt>
<dd><p>(optional) A named list of priors for the model. If not
specified, the model uses default priors (see <code><a href="coev_fit.html">help(coev_fit)</a></code>).
Alternatively, the user can specify a named list of priors. The list must
contain non-duplicated entries for any of the following parameters: the
autoregressive effects (<code>A_diag</code>), the cross effects
(<code>A_offdiag</code>), the Cholesky factor for the drift matrix (<code>L_R</code>),
the drift std. dev. parameters (<code>Q_sigma</code>), the continuous time
intercepts (<code>b</code>), the ancestral states for the traits
(<code>eta_anc</code>), the cutpoints for ordinal variables (<code>c</code>), the
overdispersion parameters for negative binomial variables (<code>phi</code>),
the shape parameters for gamma variables (<code>shape</code>), the sigma
parameters for Gaussian Processes over locations (<code>sigma_dist</code>), the
rho parameters for Gaussian Processes over locations (<code>rho_dist</code>), the
residual standard deviations when there are repeated observations
(<code>sigma_residual</code>), and the Cholesky factor for the residual
correlations when there are repeated observations (<code>L_residual</code>).
These must be entered with valid prior strings, e.g.
<code>list(A_offdiag = "normal(0, 2)")</code>. Invalid prior strings will throw
an error when the function internally checks the syntax of resulting Stan
code.</p></dd>


<dt id="arg-scale">scale<a class="anchor" aria-label="anchor" href="#arg-scale"></a></dt>
<dd><p>Logical. If <code>TRUE</code> (default), variables following the
<code>normal</code> and <code>gamma_log</code> response distributions are scaled before
fitting the model. Continuous variables following the <code>normal</code>
distribution are standardised (e.g., mean centered and divided by their
standard deviation) and positive real variables following the
<code>gamma_log</code> distribution are divided by the mean value without
centering. This approach is recommended when using default priors to
improve efficiency and ensure accurate inferences. If <code>FALSE</code>,
variables are left unscaled for model fitting. In this case, users should
take care to set sensible priors on variables.</p></dd>


<dt id="arg-estimate-correlated-drift">estimate_correlated_drift<a class="anchor" aria-label="anchor" href="#arg-estimate-correlated-drift"></a></dt>
<dd><p>Logical. If <code>TRUE</code> (default), the model
estimates the off-diagonals for the $$Q$$ drift matrix (i.e., correlated
drift). If <code>FALSE</code>, the off-diagonals for the $$Q$$ drift matrix
are set to zero.</p></dd>


<dt id="arg-estimate-residual">estimate_residual<a class="anchor" aria-label="anchor" href="#arg-estimate-residual"></a></dt>
<dd><p>Logical. If <code>TRUE</code> (default), the model
estimates residual standard deviations and residual correlations when there
are repeated observations for taxa. If <code>FALSE</code>, residual standard
deviations and residual correlations are not estimated. The latter may be
preferable in cases where repeated observations are sparse (e.g., only some
taxa have only few repeated observations). This argument only applies when
repeated observations are present in the data.</p></dd>


<dt id="arg-log-lik">log_lik<a class="anchor" aria-label="anchor" href="#arg-log-lik"></a></dt>
<dd><p>Logical. Set to <code>FALSE</code> by default. If <code>TRUE</code>, the
model returns the pointwise log likelihood, which can be used to calculate
WAIC and LOO.</p></dd>


<dt id="arg-prior-only">prior_only<a class="anchor" aria-label="anchor" href="#arg-prior-only"></a></dt>
<dd><p>Logical. If <code>FALSE</code> (default), the model is fitted to
the data and returns a posterior distribution. If <code>TRUE</code>, the model
samples from the prior only, ignoring the likelihood.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    <p>A character string containing the <span class="pkg">Stan</span> code to fit the dynamic
coevolutionary model</p>
    </div>
    <div id="details">
    <h2>Details</h2>
    <p>For further details, see <code><a href="coev_fit.html">help(coev_fit)</a></code></p>
    </div>
    <div id="references">
    <h2>References</h2>
    <p>Ringen, E., Martin, J. S., &amp; Jaeggi, A. (2021). Novel phylogenetic methods
reveal that resource-use intensification drives the evolution of "complex"
societies. <em>EcoEvoRXiv</em>. <code>doi:10.32942/osf.io/wfp95</code></p>
<p>Sheehan, O., Watts, J., Gray, R. D., Bulbulia, J., Claessens, S., Ringen,
E. J., &amp; Atkinson, Q. D. (2023). Coevolution of religious and political
authority in Austronesian societies. <em>Nature Human Behaviour</em>,
<em>7</em>(1), 38-45. <code>10.1038/s41562-022-01471-y</code></p>
    </div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p><code><a href="coev_make_standata.html">coev_make_standata</a></code>, <code><a href="coev_fit.html">coev_fit</a></code></p></div>
    </div>
    <div id="author">
    <h2>Author</h2>
    <p>Scott Claessens <a href="mailto:scott.claessens@gmail.com">scott.claessens@gmail.com</a>, Erik Ringen
<a href="mailto:erikjacob.ringen@uzh.ch">erikjacob.ringen@uzh.ch</a></p>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># make stan code</span></span></span>
<span class="r-in"><span><span class="va">stan_code</span> <span class="op">&lt;-</span> <span class="fu">coev_make_stancode</span><span class="op">(</span></span></span>
<span class="r-in"><span>  data <span class="op">=</span> <span class="va">authority</span><span class="op">$</span><span class="va">data</span>,</span></span>
<span class="r-in"><span>  variables <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>    political_authority <span class="op">=</span> <span class="st">"ordered_logistic"</span>,</span></span>
<span class="r-in"><span>    religious_authority <span class="op">=</span> <span class="st">"ordered_logistic"</span></span></span>
<span class="r-in"><span>  <span class="op">)</span>,</span></span>
<span class="r-in"><span>  id <span class="op">=</span> <span class="st">"language"</span>,</span></span>
<span class="r-in"><span>  tree <span class="op">=</span> <span class="va">authority</span><span class="op">$</span><span class="va">phylogeny</span></span></span>
<span class="r-in"><span>  <span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># print Stan code</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">stan_code</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Generated with coevolve 0.1.0.9001</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> functions {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Charles Driver's solver for the asymptotic Q matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix ksolve (matrix A, matrix Q) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int d = rows(A);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int d2 = (d * d - d) %/% 2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     matrix [d + d2, d + d2] O;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vector [d + d2] triQ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     matrix[d,d] AQ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int z = 0;         // z is row of output</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (j in 1:d) {   // for column reference of solution vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 1:j) { // and row reference...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (j &gt;= i) {  // if i and j denote a covariance parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           int y = 0;   // start new output row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           z += 1;      // shift current output row down</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           for (ci in 1:d) {   // for columns and</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (ri in 1:d) { // rows of solution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>               if (ci &gt;= ri) { // when in upper tri (inc diag)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 y += 1;       // move to next column of output</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (i == j) { // if output row is a diag element</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (ri == i) O[z, y] = 2 * A[ri, ci];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (ci == i) O[z, y] = 2 * A[ci, ri];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (i != j) { // if output row is not a diag element</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   //if column matches row, sum both A diags</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (y == z) O[z, y] = A[ri, ri] + A[ci, ci];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (y != z) { // otherwise...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     // if solution element is related to output row...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     if (ci == ri) { // if solution element is variance</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       // if variance of solution corresponds to row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       if (ci == i) O[z, y] = A[j, ci];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       // if variance of solution corresponds to col</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       if (ci == j) O[z, y] = A[i, ci];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     //if solution element is a related covariance</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     if (ci != ri &amp;&amp; (ri == i || ri == j || ci == i || ci == j )) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       // for row 1,2 / 2,1 of output,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       // if solution row ri 1 (match)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       // and column ci 3, we need A[2,3]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       if (ri == i) O[z, y] = A[j, ci];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       if (ri == j) O[z, y] = A[i, ci];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       if (ci == i) O[z, y] = A[j, ri];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       if (ci == j) O[z, y] = A[i, ri];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (is_nan(O[z, y])) O[z, y] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>               }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     z = 0; // get upper tri of Q</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (j in 1:d) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 1:j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         z += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         triQ[z] = Q[i, j];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     triQ = -O \ triQ; // get upper tri of asymQ</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     z = 0; // put upper tri of asymQ into matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (j in 1:d) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in 1:j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         z += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         AQ[i, j] = triQ[z];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (i != j) AQ[j, i] = triQ[z];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return AQ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // return number of matches of y in vector x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int num_matches(vector x, real y) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int n = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:rows(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (x[i] == y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         n += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return n;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // return indices in vector x where x == y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[] int which_equal(vector x, real y) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array [num_matches(x, y)] int match_positions;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int pos = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:rows(x)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (x[i] == y) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         match_positions[pos] = i;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         pos += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return match_positions;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_tips; // number of tips</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_tree; // number of trees</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_obs; // number of observations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=2&gt; J; // number of response traits</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N_seg; // total number of segments in the trees</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg] int&lt;lower=1&gt; node_seq; // index of tree nodes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg] int&lt;lower=0&gt; parent; // index of parent nodes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg] real ts; // time since parent</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg] int&lt;lower=0,upper=1&gt; tip; // segment ends in tip</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[J,J] int&lt;lower=0,upper=1&gt; effects_mat; // effects matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=2&gt; num_effects; // number of effects being estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N_obs,J] y; // observed data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N_obs,J] miss; // are data points missing?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_obs] int&lt;lower=1&gt; tip_id; // group index between 1 and N_tips</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0,upper=1&gt; prior_only; // should likelihood be ignored?</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[to_int(N_obs - sum(col(miss, 1)))] obs1; // observed data for variable 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[to_int(N_obs - sum(col(miss, 2)))] obs2; // observed data for variable 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   obs1 = col(y, 1)[which_equal(col(miss, 1), 0)];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   obs2 = col(y, 2)[which_equal(col(miss, 2), 0)];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;upper=0&gt;[J] A_diag; // autoregressive terms of A</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[num_effects - J] A_offdiag; // cross-lagged terms of A</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cholesky_factor_corr[J] L_R; // lower-tri choleksy decomp corr mat</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[J] Q_sigma; // std deviation parameters of the Q mat</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[J] b; // SDE intercepts</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree] vector[J] eta_anc; // ancestral states</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg - 1] vector[J] z_drift; // stochastic drift</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree] matrix[N_tips, J] terminal_drift; // drift for the tips</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ordered[3] c1; // cut points for variable 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ordered[3] c2; // cut points for variable 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg] vector[J] eta;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[J,J] A = diag_matrix(A_diag); // selection matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[J,J] Q = diag_matrix(Q_sigma) * (L_R * L_R') * diag_matrix(Q_sigma); // drift matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[J,J] Q_inf; // asymptotic covariance matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree, N_seg] matrix[J,J] VCV_tips; // vcov matrix for drift</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree,N_tips] vector[J] tdrift; // terminal drift</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // fill off diagonal of A matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int ticker = 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:J) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (j in 1:J) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (i != j) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           if (effects_mat[i,j] == 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             A[i,j] = A_offdiag[ticker];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ticker += 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           } else if (effects_mat[i,j] == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             A[i,j] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // calculate asymptotic covariance</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   Q_inf = ksolve(A, Q);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // loop over phylogenetic trees</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (t in 1:N_tree) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // setting ancestral states and placeholders</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     eta[t, node_seq[t, 1]] = eta_anc[t];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     VCV_tips[t, node_seq[t, 1]] = diag_matrix(rep_vector(-99, J));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 2:N_seg) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       matrix[J,J] A_delta; // amount of deterministic change</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       matrix[J,J] VCV; // vcov matrix of stochastic change</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       vector[J] drift_seg; // accumulated drift over the segment</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       A_delta = matrix_exp(A * ts[t, i]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       VCV = Q_inf - quad_form_sym(Q_inf, A_delta');</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       drift_seg = cholesky_decompose(VCV) * z_drift[t, i-1];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // if not a tip, add the drift parameter</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       if (tip[t, i] == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         eta[t, node_seq[t, i]] = to_vector(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           A_delta * eta[t, parent[t, i]] + ((A \ add_diag(A_delta, -1)) * b) + drift_seg</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         VCV_tips[t, node_seq[t, i]] = diag_matrix(rep_vector(-99, J));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       // if is a tip, omit, we'll deal with it in the model block;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         eta[t, node_seq[t, i]] = to_vector(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>           A_delta * eta[t, parent[t, i]] + ((A \ add_diag(A_delta, -1)) * b)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         VCV_tips[t, node_seq[t, i]] = VCV;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:N_tips) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       tdrift[t,i] = cholesky_decompose(VCV_tips[t,i]) * to_vector(terminal_drift[t][i,]);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (t in 1:N_tree) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     eta_anc[t] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:(N_seg - 1)) z_drift[t, i] ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     to_vector(terminal_drift[t]) ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   A_offdiag ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   A_diag ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   L_R ~ lkj_corr_cholesky(4);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   Q_sigma ~ std_normal();</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c1 ~ normal(0, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c2 ~ normal(0, 2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (!prior_only) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:N_obs) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       vector[N_tree] lp = rep_vector(0.0, N_tree);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (t in 1:N_tree) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (miss[i,1] == 0) lp[t] += ordered_logistic_lpmf(to_int(y[i,1]) | eta[t,tip_id[i]][1] + tdrift[t,tip_id[i]][1], c1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (miss[i,2] == 0) lp[t] += ordered_logistic_lpmf(to_int(y[i,2]) | eta[t,tip_id[i]][2] + tdrift[t,tip_id[i]][2], c2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       target += log_sum_exp(lp);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[N_tree,N_obs,J] real yrep; // predictive checks</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[J,J] cor_R; // correlated drift</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cor_R = multiply_lower_tri_self_transpose(L_R);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     array[N_tree,N_tips] vector[J] terminal_drift_rep;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:N_tips) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (t in 1:N_tree) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (j in 1:J) terminal_drift_rep[t,i][j] = normal_rng(0, 1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         terminal_drift_rep[t,i] = cholesky_decompose(VCV_tips[t, i]) * terminal_drift_rep[t,i];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in 1:N_obs) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (t in 1:N_tree) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         yrep[t,i,1] = ordered_logistic_rng(eta[t,tip_id[i]][1] + terminal_drift_rep[t,tip_id[i]][1], c1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         yrep[t,i,2] = ordered_logistic_rng(eta[t,tip_id[i]][2] + terminal_drift_rep[t,tip_id[i]][2], c2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Scott Claessens, Erik Ringen.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

      </footer></div>






  </body></html>

